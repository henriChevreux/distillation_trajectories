"""
Trajectory validation script for diffusion models.
This script validates that the trajectories generated by the diffusion models
are deterministic and not just random.
"""

import os
import sys
import torch
import numpy as np
import matplotlib.pyplot as plt
from sklearn.decomposition import PCA

# Add the project root directory to the Python path
project_root = os.path.abspath(os.path.join(os.path.dirname(__file__), '..'))
sys.path.insert(0, project_root)

from config.config import Config
from models import SimpleUNet
from analysis.trajectory_comparison import generate_trajectory

def validate_trajectory_determinism(model, config, device, num_runs=3):
    """
    Validate that the trajectory generation is deterministic
    by generating multiple trajectories from the same starting point.
    
    Args:
        model: The diffusion model
        config: Configuration object
        device: Device to run on
        num_runs: Number of trajectories to generate
        
    Returns:
        Dictionary with validation results
    """
    print(f"Validating trajectory determinism with {num_runs} runs...")
    
    # Set seed for reproducibility
    torch.manual_seed(42)
    
    # Generate fixed random noise
    fixed_noise = torch.randn(1, config.channels, config.image_size, config.image_size)
    
    # Generate multiple trajectories from the same starting point
    trajectories = []
    for i in range(num_runs):
        print(f"Generating trajectory {i+1}/{num_runs}...")
        # Reset seed to ensure deterministic behavior in the model
        torch.manual_seed(42)
        np.random.seed(42)
        
        # Generate trajectory
        trajectory = generate_trajectory(model, fixed_noise, config.timesteps, device)
        trajectories.append(trajectory)
    
    # Check if all trajectories have the same length
    lengths = [len(traj) for traj in trajectories]
    all_same_length = all(length == lengths[0] for length in lengths)
    
    # Calculate mean squared error between trajectories
    mse_values = []
    for i in range(num_runs):
        for j in range(i+1, num_runs):
            # Calculate MSE for each pair of trajectories
            mse = 0.0
            for t in range(min(len(trajectories[i]), len(trajectories[j]))):
                # Convert tensors to numpy arrays
                img_i = trajectories[i][t].numpy()
                img_j = trajectories[j][t].numpy()
                # Calculate MSE
                mse += np.mean((img_i - img_j) ** 2)
            # Normalize by the number of timesteps
            mse /= min(len(trajectories[i]), len(trajectories[j]))
            mse_values.append(mse)
    
    # Calculate statistics
    mean_mse = np.mean(mse_values)
    max_mse = np.max(mse_values)
    
    # Visualize the first and last images of each trajectory
    output_dir = os.path.join(config.analysis_dir, "trajectory_validation")
    os.makedirs(output_dir, exist_ok=True)
    
    # Plot first and last images
    fig, axes = plt.subplots(num_runs, 2, figsize=(10, 5 * num_runs))
    for i in range(num_runs):
        # First image (noise)
        first_img = trajectories[i][0].squeeze().numpy().transpose(1, 2, 0)
        # Normalize to [0, 1] for visualization
        first_img = (first_img - first_img.min()) / (first_img.max() - first_img.min())
        axes[i, 0].imshow(first_img)
        axes[i, 0].set_title(f"Run {i+1} - First Image (Noise)")
        axes[i, 0].axis('off')
        
        # Last image (denoised)
        last_img = trajectories[i][-1].squeeze().numpy().transpose(1, 2, 0)
        # Normalize to [0, 1] for visualization
        last_img = (last_img - last_img.min()) / (last_img.max() - last_img.min())
        axes[i, 1].imshow(last_img)
        axes[i, 1].set_title(f"Run {i+1} - Last Image (Denoised)")
        axes[i, 1].axis('off')
    
    plt.tight_layout()
    plt.savefig(os.path.join(output_dir, "trajectory_first_last_images.png"), dpi=300)
    plt.close()
    
    # Visualize trajectories using PCA
    # Convert trajectories to feature vectors
    all_features = []
    run_indices = []
    timestep_indices = []
    
    for run_idx, trajectory in enumerate(trajectories):
        for t_idx, img in enumerate(trajectory):
            # Flatten the image
            features = img.reshape(-1).numpy()
            all_features.append(features)
            run_indices.append(run_idx)
            timestep_indices.append(t_idx)
    
    all_features = np.array(all_features)
    
    # Fit PCA
    pca = PCA(n_components=2)
    pca_features = pca.fit_transform(all_features)
    
    # Create figure
    plt.figure(figsize=(12, 10))
    
    # Plot trajectories
    colors = ['b', 'r', 'g', 'c', 'm', 'y', 'k']
    for run_idx in range(num_runs):
        # Get indices for this run
        indices = [i for i, r in enumerate(run_indices) if r == run_idx]
        # Get PCA features for this run
        run_features = pca_features[indices]
        # Get timesteps for this run
        run_timesteps = [timestep_indices[i] for i in indices]
        
        # Plot trajectory
        plt.scatter(
            run_features[:, 0], run_features[:, 1],
            c=run_timesteps, cmap='viridis',
            marker='o', alpha=0.7,
            label=f'Run {run_idx+1}'
        )
        
        # Connect points in sequence
        for i in range(len(run_features) - 1):
            plt.plot(
                [run_features[i, 0], run_features[i+1, 0]],
                [run_features[i, 1], run_features[i+1, 1]],
                colors[run_idx % len(colors)] + '-', alpha=0.3
            )
    
    # Add colorbar
    cbar = plt.colorbar()
    cbar.set_label('Timestep')
    
    # Add labels and title
    plt.xlabel(f'Principal Component 1 (Explained Variance: {pca.explained_variance_ratio_[0]:.2f})')
    plt.ylabel(f'Principal Component 2 (Explained Variance: {pca.explained_variance_ratio_[1]:.2f})')
    plt.title('PCA of Multiple Diffusion Trajectories from Same Starting Point')
    plt.legend()
    
    # Save figure
    plt.savefig(os.path.join(output_dir, "trajectory_pca_comparison.png"), dpi=300, bbox_inches='tight')
    plt.close()
    
    # Return validation results
    return {
        "all_same_length": all_same_length,
        "trajectory_length": lengths[0] if all_same_length else lengths,
        "mean_mse": mean_mse,
        "max_mse": max_mse,
        "is_deterministic": mean_mse < 1e-10  # Threshold for considering trajectories identical
    }

def main():
    """Main function to run the trajectory validation"""
    # Initialize configuration
    config = Config()
    config.analysis_dir = "analysis"
    config.timesteps = 50
    
    # Create necessary directories
    os.makedirs(config.analysis_dir, exist_ok=True)
    
    # Determine device
    device = torch.device("cuda" if torch.cuda.is_available() else "mps" if torch.backends.mps.is_available() else "cpu")
    print(f"Using device: {device}")
    
    # Load teacher model
    teacher_model_path = os.path.join(project_root, 'output', 'models', 'teacher', 'model_epoch_1.pt')
    print(f"Loading teacher model from {teacher_model_path}")
    
    if not os.path.exists(teacher_model_path):
        print(f"ERROR: Teacher model not found at {teacher_model_path}")
        sys.exit(1)
    
    # Initialize teacher model
    teacher_model = SimpleUNet(config).to(device)
    
    teacher_state_dict = torch.load(teacher_model_path, map_location=device)
    teacher_model.load_state_dict(teacher_state_dict)
    teacher_model.eval()
    
    print(f"Teacher model loaded successfully")
    print(f"Teacher model dimensions: {teacher_model.dims}")
    
    # Validate trajectory determinism
    results = validate_trajectory_determinism(teacher_model, config, device)
    
    # Print results
    print("\nTrajectory Validation Results:")
    print(f"All trajectories have the same length: {results['all_same_length']}")
    print(f"Trajectory length: {results['trajectory_length']}")
    print(f"Mean MSE between trajectories: {results['mean_mse']}")
    print(f"Max MSE between trajectories: {results['max_mse']}")
    print(f"Is deterministic: {results['is_deterministic']}")
    
    if results['is_deterministic']:
        print("\nVALIDATION PASSED: The teacher trajectory generation is deterministic.")
    else:
        print("\nVALIDATION FAILED: The teacher trajectory generation is NOT deterministic.")
        print("This suggests that there might be randomness in the trajectory generation process.")
    
    print(f"\nValidation results saved in {os.path.join(config.analysis_dir, 'trajectory_validation')}")

if __name__ == "__main__":
    main() 